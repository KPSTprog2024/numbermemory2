<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>なんばーめもりー</title>
    <meta name="theme-color" content="#2196F3">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #f0f8ff 0%, #a2d2ff 100%);
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
            overflow: hidden;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* オンライン・オフラインステータス表示 */
        #status-display {
            position: absolute;
            bottom: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
    <!-- Phaser.jsのCDN -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
</head>
<body>
<div id="game-container"></div>

<script>
/* ============ 簡易SE/画像(Base64) ============ */
const ASSETS = {
    click: "data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQgAAA==", // 無音
    success: "data:audio/wav;base64,UklGRqQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YYAAAEAgAAAAAAAgAgAA", // 無音
    wrong: "data:audio/wav;base64,UklGRlIAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YYAAAEAgAAAAAAAgAgAA", // 無音
    levelup: "data:audio/wav;base64,UklGRrQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YYAAAEAgAAAAAAAgAgAA", // 無音
    countdown: "data:audio/wav;base64,UklGRpAAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YYAAAEAgAAAAAAAgAgAA", // 無音
    character: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABkElEQVR4nO3avUoDQRjA8e8Ej0EzoFJToJGpJIC9gSLQJIgXoS24gViJVJIE5cQ12ol0xj8kVgyTsz3y/kjs++/fB2QhxkE6AMYwBGMAYQxBGMMQZjBGEIQyBG2wBaSdZIZ1kINsdQrcvlf9Tv3Puzrp4XXagA6wjGBAU4cE6hM8cll1uFt3A0Ay4ABObBDB4ZPCNQ4CvTwl0vB0jH3AZk0wC9kHAJOkl4C4TbwvEdfu9pFr4wBtkQH1nNNwQb4yTAXkQp9AyB7RMAGXEApTQHTCHOGQI+HT0HHLMOAmOS8YEjFQX5NugMoRcwK/wWdhIcYwBGMAYQxBGMMQZjBGEIQzBu4ym1Id6AEow7/EwRf05AAAAAElFTkSuQmCC"
};
/* ============================================ */

/* ============ 効果音をAudioインスタンスで用意 =========== */
function playSE(type) {
    if (ASSETS[type]) {
        const audio = new Audio(ASSETS[type]);
        audio.play();
    }
}
/* ============================================ */

/* ============ 定数/ユーティリティ ============ */
const COLORS = {
    primary: 0x2196F3,
    primaryHover: 0x1976D2,
    success: 0x4CAF50,
    successHover: 0x388E3C,
    danger: 0xFF5722,
    dangerHover: 0xD84315,
    info: 0x2196F3,
    infoHover: 0x1976D2,
    warning: 0xFFD700,
    selected: 0xFF9800,
    selectedHover: 0xFB8C00
};

function calculateResponsiveSize(scene, baseSize) {
    const { width, height } = scene.scale;
    const minDimension = Math.min(width, height);
    return Math.max(Math.round(minDimension * baseSize), 16);
}

function createCustomButton(scene, text, x, y, width, height, backgroundColor, hoverColor, onClick) {
    const buttonContainer = scene.add.container(x, y);
    const buttonBackground = scene.add.graphics();
    buttonBackground.fillStyle(backgroundColor, 1);
    buttonBackground.fillRoundedRect(-width / 2, -height / 2, width, height, 20);

    const fontSize = calculateResponsiveSize(scene, 0.04);
    const buttonText = scene.add.text(0, 0, text, {
        fontSize: `${fontSize}px`,
        fill: '#fff',
        align: 'center',
    }).setOrigin(0.5, 0.5);

    buttonContainer.add([buttonBackground, buttonText]);
    buttonContainer.setSize(width, height);
    buttonContainer.setInteractive({ useHandCursor: true });
    buttonContainer.defaultColor = backgroundColor;
    buttonContainer.hoverColor = hoverColor;
    buttonContainer.selected = false;

    buttonContainer.on('pointerover', () => {
        if (buttonContainer.selected) {
            buttonBackground.clear();
            buttonBackground.fillStyle(COLORS.selectedHover, 1);
            buttonBackground.fillRoundedRect(-width / 2, -height / 2, width, height, 20);
        } else {
            buttonBackground.clear();
            buttonBackground.fillStyle(buttonContainer.hoverColor, 1);
            buttonBackground.fillRoundedRect(-width / 2, -height / 2, width, height, 20);
        }
    });
    buttonContainer.on('pointerout', () => {
        if (buttonContainer.selected) {
            buttonBackground.clear();
            buttonBackground.fillStyle(COLORS.selected, 1);
            buttonBackground.fillRoundedRect(-width / 2, -height / 2, width, height, 20);
        } else {
            buttonBackground.clear();
            buttonBackground.fillStyle(buttonContainer.defaultColor, 1);
            buttonBackground.fillRoundedRect(-width / 2, -height / 2, width, height, 20);
        }
    });
    buttonContainer.on('pointerdown', () => {
        playSE('click');
        scene.tweens.add({
            targets: buttonContainer,
            scale: { from: 1, to: 0.95 },
            yoyo: true,
            duration: 100
        });
        onClick();
    });
    return buttonContainer;
}
/* ============================================ */

class BaseScene extends Phaser.Scene {
    constructor(key) {
        super({ key: key });
    }
    init(data) {
        this.displayTime = data.displayTime || 2000;
        this.level = data.level || 1;
        this.gridSize = data.gridSize || 3;
        this.gameMode = data.gameMode || 'number';
    }
    createBackground() {
        const { width, height } = this.scale;
        // グラデ背景
        const bg = this.add.graphics();
        bg.fillGradientStyle(0xffafcc, 0xffafcc, 0xa2d2ff, 0xa2d2ff, 1);
        bg.fillRect(0, 0, width, height);

        // ふわふわの泡や星
        for (let i = 0; i < 15; i++) {
            const x = Phaser.Math.Between(0, width);
            const y = Phaser.Math.Between(0, height);
            const size = Phaser.Math.Between(10, 30);
            if (Math.random() > 0.5) {
                const circle = this.add.circle(x, y, size, 0xffffff, 0.09);
                this.tweens.add({
                    targets: circle,
                    y: y - Phaser.Math.Between(30, 100),
                    alpha: { from: 0.09, to: 0 },
                    duration: Phaser.Math.Between(4000, 8000),
                    repeat: -1,
                    yoyo: true
                });
            } else {
                const star = this.add.star(x, y, 5, size/2, size, 0xffffff, 0.07);
                this.tweens.add({
                    targets: star,
                    y: y + Phaser.Math.Between(30, 120),
                    alpha: { from: 0.07, to: 0 },
                    duration: Phaser.Math.Between(5000, 10000),
                    repeat: -1,
                    yoyo: true
                });
            }
        }
    }
    addCharacter(x, y, scale = 1, message = null) {
        const character = this.add.image(x, y, 'character').setScale(scale);
        this.tweens.add({
            targets: character,
            y: y + 10,
            duration: 1000,
            yoyo: true,
            repeat: -1,
            ease: 'Sine.easeInOut'
        });
        if (message) {
            const { width } = this.scale;
            const bubblePadding = 10;
            const bubbleWidth = width * 0.34;
            const bubbleHeight = 60;
            const bubble = this.add.graphics();
            bubble.fillStyle(0xffffff, 0.9);
            bubble.fillRoundedRect(
                x - bubbleWidth / 2,
                y - 120 - bubbleHeight,
                bubbleWidth,
                bubbleHeight,
                18
            );
            bubble.fillTriangle(
                x, y - 120,
                x - 12, y - 110,
                x + 12, y - 110
            );
            const fontSize = calculateResponsiveSize(this, 0.025);
            const text = this.add.text(
                x, y - 120 - bubbleHeight / 2,
                message,
                {
                    fontSize: `${fontSize}px`,
                    fill: '#000',
                    align: 'center',
                    wordWrap: { width: bubbleWidth - bubblePadding * 2 }
                }
            ).setOrigin(0.5);
            this.time.delayedCall(3000, () => {
                bubble.destroy();
                text.destroy();
            });
        }
        return character;
    }
    drawGrid() {
        const { width, height } = this.scale;
        const gridSize = this.gridSize;
        const gridLength = width < height ? width * 0.8 : height * 0.8;
        const startX = (width - gridLength) / 2;
        const startY = (height - gridLength) / 2;
        const cellSize = gridLength / gridSize;
        const graphics = this.add.graphics();
        graphics.lineStyle(4, 0x000000, 1);
        for (let i = 0; i <= gridSize; i++) {
            graphics.moveTo(startX + i * cellSize, startY);
            graphics.lineTo(startX + i * cellSize, startY + gridLength);
            graphics.moveTo(startX, startY + i * cellSize);
            graphics.lineTo(startX + gridLength, startY + i * cellSize);
        }
        graphics.strokePath();
    }
    createParticleEffect() {
        const { width, height } = this.scale;
        // 紙吹雪
        for (let i = 0; i < 40; i++) {
            const x = Phaser.Math.Between(0, width);
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
            const color = Phaser.Utils.Array.GetRandom(colors);
            let particle;
            const size = Phaser.Math.Between(10, 24);
            const shape = Phaser.Math.Between(0, 2);
            if (shape === 0) {
                particle = this.add.circle(x, -50, size, color);
            } else if (shape === 1) {
                particle = this.add.rectangle(x, -50, size, size, color);
            } else {
                particle = this.add.star(x, -50, 5, size / 2, size, color);
            }
            this.tweens.add({
                targets: particle,
                y: height + 100,
                x: x + Phaser.Math.Between(-100, 100),
                angle: Phaser.Math.Between(0, 360),
                duration: Phaser.Math.Between(2000, 5000),
                delay: Phaser.Math.Between(0, 2000),
                onComplete: () => particle.destroy()
            });
        }
        // キラキラ
        for (let i = 0; i < 14; i++) {
            this.time.delayedCall(100 * i, () => {
                const x = Phaser.Math.Between(width * 0.2, width * 0.8);
                const y = Phaser.Math.Between(height * 0.2, height * 0.8);
                const star = this.add.star(x, y, 5, 5, 13, 0xffff00);
                this.tweens.add({
                    targets: star,
                    angle: 360,
                    scale: { from: 0, to: 1 },
                    alpha: { from: 1, to: 0 },
                    duration: 900,
                    onComplete: () => star.destroy()
                });
            });
        }
    }
    preload() {
        // 画像読み込み（Base64利用）
        this.load.image('character', ASSETS.character);
    }
}

/* ========== シーン1: Selection =========== */
class SelectionScene extends BaseScene {
    preload() { super.preload(); }
    create() {
        this.createBackground();
        const { width, height } = this.scale;
        // キャラ
        this.addCharacter(width * 0.85, height * 0.85, 0.55, 'げーむのせっていをえらんでね！');
        // タイトル
        const titleFontSize = calculateResponsiveSize(this, 0.06);
        this.add.text(width / 2, height * 0.1, 'げーむせっていをえらんでね', {
            fontSize: `${titleFontSize}px`,
            fill: '#000',
            align: 'center',
            wordWrap: { width: width * 0.9 }
        }).setOrigin(0.5, 0.5);

        // ボタン設定
        const buttonWidth = width * 0.25;
        const buttonHeight = height * 0.1;
        const buttonSpacing = width * 0.02;
        const options = [
            {
                title: 'ひょうじじかんをえらんでね',
                yPosition: 0.25,
                items: [
                    { label: '0.5びょう', value: 500 },
                    { label: '1びょう', value: 1000 },
                    { label: '3びょう', value: 3000 }
                ],
                buttonsArray: 'timeButtons',
                onSelect: (button, value) => {
                    this.selectedTime = value;
                    this.timeButtons.forEach(btn => { btn.selected = false; btn.emit('pointerout'); });
                    button.selected = true; button.emit('pointerout');
                    this.events.emit('selectionChanged');
                }
            },
            {
                title: 'ぐりっどさいずをえらんでね',
                yPosition: 0.45,
                items: [
                    { label: '3x3', value: 3 },
                    { label: '4x4', value: 4 },
                    { label: '5x5', value: 5 }
                ],
                buttonsArray: 'gridSizeButtons',
                onSelect: (button, value) => {
                    this.selectedGridSize = value;
                    this.gridSizeButtons.forEach(btn => { btn.selected = false; btn.emit('pointerout'); });
                    button.selected = true; button.emit('pointerout');
                    this.events.emit('selectionChanged');
                }
            },
            {
                title: 'げーむもーどをえらんでね',
                yPosition: 0.65,
                items: [
                    { label: 'すうじもーど', value: 'number' },
                    { label: 'いろもーど', value: 'color' }
                ],
                buttonsArray: 'gameModeButtons',
                onSelect: (button, value) => {
                    this.selectedGameMode = value;
                    this.gameModeButtons.forEach(btn => { btn.selected = false; btn.emit('pointerout'); });
                    button.selected = true; button.emit('pointerout');
                    this.events.emit('selectionChanged');
                }
            }
        ];
        options.forEach(option => {
            const sectionFontSize = calculateResponsiveSize(this, 0.05);
            this.add.text(width / 2, height * option.yPosition, option.title, {
                fontSize: `${sectionFontSize}px`,
                fill: '#000',
                align: 'center',
                wordWrap: { width: width * 0.9 }
            }).setOrigin(0.5, 0.5);
            const totalWidth = option.items.length * buttonWidth + (option.items.length - 1) * buttonSpacing;
            let startX = (width - totalWidth) / 2 + buttonWidth / 2;
            const startY = height * (option.yPosition + 0.08);
            option.buttons = [];
            option.items.forEach((item, index) => {
                const buttonX = startX + index * (buttonWidth + buttonSpacing);
                const button = createCustomButton(
                    this,
                    item.label,
                    buttonX,
                    startY,
                    buttonWidth,
                    buttonHeight,
                    COLORS.primary,
                    COLORS.primaryHover,
                    () => option.onSelect(button, item.value)
                );
                option.buttons.push(button);
            });
            this[option.buttonsArray] = option.buttons;
        });
        // スタートボタン
        const startButtonWidth = width * 0.6;
        const startButtonHeight = height * 0.12;
        const startButton = createCustomButton(
            this,
            'スタート',
            width / 2,
            height * 0.85,
            startButtonWidth,
            startButtonHeight,
            COLORS.success,
            COLORS.successHover,
            () => {
                if (startButton.getData('enabled')) {
                    this.scene.start('CountdownScene', {
                        displayTime: this.selectedTime,
                        level: 1,
                        gridSize: this.selectedGridSize,
                        gameMode: this.selectedGameMode
                    });
                }
            }
        );
        startButton.setAlpha(0.5);
        startButton.setData('enabled', false);
        const updateStartButton = () => {
            if (this.selectedTime && this.selectedGridSize && this.selectedGameMode) {
                startButton.setAlpha(1);
                startButton.setData('enabled', true);
            } else {
                startButton.setAlpha(0.5);
                startButton.setData('enabled', false);
            }
        };
        this.events.on('selectionChanged', updateStartButton, this);
    }
}

/* ========== シーン2: Countdown =========== */
class CountdownScene extends BaseScene {
    constructor() { super('CountdownScene'); }
    preload() { super.preload(); }
    create() {
        this.createBackground();
        const { width, height } = this.scale;
        this.count = 3;
        this.drawGrid();
        const countFontSize = calculateResponsiveSize(this, 0.2);
        this.countText = this.add.text(width / 2, height / 2, this.count, {
            fontSize: `${countFontSize}px`,
            fill: '#FF0000',
            align: 'center'
        }).setOrigin(0.5, 0.5);
        this.tweens.add({
            targets: this.countText,
            scale: { from: 1, to: 1.5 },
            yoyo: true,
            repeat: -1,
            duration: 500
        });
        playSE('countdown');
        this.timeEvent = this.time.addEvent({
            delay: 1000,
            callback: this.updateCountdown,
            callbackScope: this,
            loop: true
        });
    }
    updateCountdown() {
        this.count -= 1;
        if (this.count > 0) {
            this.countText.setText(this.count);
            playSE('countdown');
        } else {
            this.timeEvent.remove(false);
            this.tweens.killTweensOf(this.countText);
            this.countText.destroy();
            this.scene.start('GameScene', {
                displayTime: this.displayTime,
                level: this.level,
                gridSize: this.gridSize,
                gameMode: this.gameMode
            });
        }
    }
}

/* ========== シーン3: Game =========== */
class GameScene extends BaseScene {
    constructor() { super('GameScene'); }
    preload() { super.preload(); }
    init(data) {
        super.init(data);
        this.expectedNumber = 1;
        this.numbers = [];
        this.grid = [];
        this.wrongCells = [];
        this.totalTargets = 0;
        this.clickedTargets = 0;
        this.hintUsed = false;
    }
    create() {
        this.createBackground();
        const { width, height } = this.scale;
        this.addCharacter(width * 0.85, height * 0.85, 0.52, 'よーく おぼえてね！');

        const levelFontSize = calculateResponsiveSize(this, 0.04);
        this.add.text(width * 0.05, height * 0.05, `れべる: ${this.level}`, {
            fontSize: `${levelFontSize}px`,
            fill: '#000'
        }).setOrigin(0, 0);

        this.drawGrid();

        if (this.gameMode === 'number') {
            this.placeNumbers();
        } else if (this.gameMode === 'color') {
            this.placeColors();
        }
        this.time.delayedCall(this.displayTime, () => {
            this.hideElements();
        }, [], this);

        // ヒントボタン
        const hintButton = createCustomButton(
            this, "？",
            width * 0.93, height * 0.06,
            width * 0.08, width * 0.08,
            COLORS.info, COLORS.infoHover,
            () => this.showHint()
        );
    }

    showHint() {
        if (this.hintUsed) return;
        this.hintUsed = true;
        if (this.gameMode === 'number') {
            const nextCell = this.grid.find(cell => cell.number === this.expectedNumber);
            if (nextCell && nextCell.object) {
                nextCell.object.setVisible(true);
                this.tweens.add({
                    targets: nextCell.object,
                    alpha: { from: 1, to: 0 },
                    yoyo: true,
                    repeat: 2,
                    duration: 300,
                    onComplete: () => {
                        nextCell.object.setVisible(false);
                        nextCell.object.setAlpha(1);
                    }
                });
            }
        } else if (this.gameMode === 'color') {
            this.grid.forEach(cell => {
                if (cell.color !== null && !cell.clicked) {
                    cell.object.setVisible(true);
                    this.tweens.add({
                        targets: cell.object,
                        alpha: { from: 1, to: 0 },
                        yoyo: true,
                        repeat: 2,
                        duration: 300,
                        onComplete: () => {
                            cell.object.setVisible(false);
                            cell.object.setAlpha(1);
                        }
                    });
                }
            });
        }
    }

    placeNumbers() {
        const totalNumbers = this.level + 2;
        if (totalNumbers > this.gridSize * this.gridSize) {
            alert('れべるがたかすぎます！ げーむをしゅうりょうします。');
            this.scene.start('SelectionScene');
            return;
        }
        this.numbers = [];
        for (let i = 1; i <= totalNumbers; i++) this.numbers.push(i);

        const availableIndices = Phaser.Utils.Array.NumberArray(0, this.grid.length - 1);
        Phaser.Utils.Array.Shuffle(availableIndices);

        this.numbers.forEach((num, index) => {
            const gridIndex = availableIndices[index];
            const cell = this.grid[gridIndex];
            cell.number = num;
            const numberFontSize = calculateResponsiveSize(this, 0.06);
            const numberText = this.add.text(cell.x, cell.y, num, {
                fontSize: `${numberFontSize}px`,
                fill: '#fff',
                backgroundColor: Phaser.Display.Color.IntegerToColor(COLORS.danger).rgba,
                padding: { x: 10, y: 10 },
                borderRadius: 10,
                align: 'center'
            }).setOrigin(0.5, 0.5).setVisible(true);
            cell.object = numberText;
        });
        this.totalTargets = this.numbers.length;
    }

    placeColors() {
        const totalColors = this.level + 2;
        if (totalColors > this.gridSize * this.gridSize) {
            alert('れべるがたかすぎます！ げーむをしゅうりょうします。');
            this.scene.start('SelectionScene');
            return;
        }
        const colors = [
            0xff5733, 0x33ff57, 0x3357ff, 0xff33a8, 0xfff933,
            0x33fff5, 0x8e44ad, 0xe67e22, 0x2ecc71, 0x3498db
        ];
        const colorNames = {
            0xff5733: 'あか', 0x33ff57: 'みどり', 0x3357ff: 'あお',
            0xff33a8: 'ピンク', 0xfff933: 'きいろ', 0x33fff5: 'みずいろ',
            0x8e44ad: 'むらさき', 0xe67e22: 'オレンジ', 0x2ecc71: 'ライム', 0x3498db: 'あおい'
        };
        const selectedColors = Phaser.Utils.Array.Shuffle(colors).slice(0, totalColors);

        const availableIndices = Phaser.Utils.Array.NumberArray(0, this.grid.length - 1);
        Phaser.Utils.Array.Shuffle(availableIndices);

        selectedColors.forEach((color, index) => {
            const gridIndex = availableIndices[index];
            const cell = this.grid[gridIndex];
            cell.color = color;
            const colorBlock = this.add.rectangle(cell.x, cell.y, cell.width * 0.8, cell.height * 0.6, color)
                .setOrigin(0.5, 0.5)
                .setAlpha(1);
            const colorNameFontSize = calculateResponsiveSize(this, 0.025);
            const colorName = this.add.text(
                cell.x, cell.y + cell.height * 0.19,
                colorNames[color] || '', {
                    fontSize: `${colorNameFontSize}px`,
                    fill: '#fff',
                    stroke: '#000', strokeThickness: 3,
                    align: 'center'
                }).setOrigin(0.5, 0.5);
            const group = this.add.container(cell.x, cell.y, [colorBlock, colorName]);
            cell.object = group;
        });
        this.totalTargets = selectedColors.length;
    }

    hideElements() {
        this.grid.forEach(cell => {
            if (cell.object) cell.object.setVisible(false);
        });
    }
    handleGridClick(row, col) {
        const clickedCell = this.grid.find(cell => cell.row === row && cell.col === col);
        if (!clickedCell) return;
        if (this.gameMode === 'number') {
            if (clickedCell.number === null) {
                this.wrongCells.push({ row, col });
                playSE('wrong');
                this.scene.start('RetryScene', {
                    displayTime: this.displayTime,
                    level: this.level,
                    gridSize: this.gridSize,
                    gameMode: this.gameMode,
                    grid: this.grid,
                    wrongCells: this.wrongCells
                });
                return;
            }
            if (clickedCell.clicked) return;
            if (clickedCell.number === this.expectedNumber) {
                clickedCell.clicked = true;
                clickedCell.object.setStyle({ backgroundColor: Phaser.Display.Color.IntegerToColor(COLORS.success).rgba });
                clickedCell.object.setVisible(true);
                clickedCell.zone.disableInteractive();
                playSE('success');
                this.tweens.add({
                    targets: clickedCell.object,
                    scale: { from: 1, to: 1.2 },
                    yoyo: true,
                    duration: 200
                });
                this.expectedNumber += 1;
                if (this.expectedNumber > this.numbers.length) {
                    playSE('levelup');
                    this.time.delayedCall(500, () => {
                        this.scene.start('ClearScene', {
                            displayTime: this.displayTime,
                            level: this.level,
                            gridSize: this.gridSize,
                            gameMode: this.gameMode,
                            grid: this.grid
                        });
                    }, [], this);
                }
            } else {
                this.wrongCells.push({ row, col });
                playSE('wrong');
                if (clickedCell.object) {
                    this.tweens.add({
                        targets: clickedCell.object,
                        scale: { from: 1, to: 0.8 },
                        yoyo: true,
                        duration: 200
                    });
                }
                this.scene.start('RetryScene', {
                    displayTime: this.displayTime,
                    level: this.level,
                    gridSize: this.gridSize,
                    gameMode: this.gameMode,
                    grid: this.grid,
                    wrongCells: this.wrongCells
                });
            }
        } else if (this.gameMode === 'color') {
            if (clickedCell.color === null) {
                this.wrongCells.push({ row, col });
                playSE('wrong');
                this.scene.start('RetryScene', {
                    displayTime: this.displayTime,
                    level: this.level,
                    gridSize: this.gridSize,
                    gameMode: this.gameMode,
                    grid: this.grid,
                    wrongCells: this.wrongCells
                });
                return;
            }
            if (clickedCell.clicked) return;
            clickedCell.clicked = true;
            clickedCell.object.setVisible(true);
            clickedCell.zone.disableInteractive();
            playSE('success');
            this.tweens.add({
                targets: clickedCell.object,
                scale: { from: 1, to: 1.2 },
                yoyo: true,
                duration: 200
            });
            this.clickedTargets += 1;
            if (this.clickedTargets >= this.totalTargets) {
                playSE('levelup');
                this.time.delayedCall(500, () => {
                    this.scene.start('ClearScene', {
                        displayTime: this.displayTime,
                        level: this.level,
                        gridSize: this.gridSize,
                        gameMode: this.gameMode,
                        grid: this.grid
                    });
                }, [], this);
            }
        }
    }
    drawGrid() {
        super.drawGrid();
        const { width, height } = this.scale;
        const gridSize = this.gridSize;
        const gridLength = width < height ? width * 0.8 : height * 0.8;
        const startX = (width - gridLength) / 2;
        const startY = (height - gridLength) / 2;
        const cellSize = gridLength / gridSize;
        for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
                const x = startX + col * cellSize + cellSize / 2;
                const y = startY + row * cellSize + cellSize / 2;
                const zone = this.add.zone(x, y, cellSize, cellSize)
                    .setRectangleDropZone(cellSize, cellSize)
                    .setInteractive({ useHandCursor: true });
                zone.on('pointerover', () => { zone.setAlpha(0.3); });
                zone.on('pointerout', () => { zone.setAlpha(0); });
                zone.on('pointerdown', () => { this.handleGridClick(row, col); });
                this.grid.push({
                    row, col, x, y, width: cellSize, height: cellSize,
                    number: null, color: null, object: null, zone: zone, clicked: false
                });
            }
        }
    }
}

/* ========== シーン4: Clear =========== */
class ClearScene extends BaseScene {
    constructor() { super('ClearScene'); }
    preload() { super.preload(); }
    init(data) {
        super.init(data);
        this.grid = data.grid;
        this.messages = [
            'すごい！', 'よくできた！', 'ナイス！', 'かんせい！',
            'がんばったね！', 'きらきら！', 'ピカピカ！', 'スマート！', 'トップだ！', 'ファンタスティック！'
        ];
    }
    create() {
        this.createBackground();
        const { width, height } = this.scale;
        this.addCharacter(width * 0.15, height * 0.85, 0.54, 'つぎのレベルもがんばろう！');
        this.drawGrid();
        this.grid.forEach(cell => {
            if (this.gameMode === 'number' && cell.number !== null) {
                const numberFontSize = calculateResponsiveSize(this, 0.06);
                this.add.text(cell.x, cell.y, cell.number, {
                    fontSize: `${numberFontSize}px`,
                    fill: '#fff',
                    backgroundColor: Phaser.Display.Color.IntegerToColor(COLORS.success).rgba,
                    padding: { x: 10, y: 10 },
                    borderRadius: 10,
                    align: 'center'
                }).setOrigin(0.5, 0.5).setVisible(true);
            } else if (this.gameMode === 'color' && cell.color !== null) {
                const colorBlock = this.add.rectangle(cell.x, cell.y, cell.width * 0.8, cell.height * 0.6, cell.color)
                    .setOrigin(0.5, 0.5)
                    .setAlpha(1);
            }
        });
        const clearFontSize = calculateResponsiveSize(this, 0.08);
        this.add.text(width / 2, height * 0.18, 'クリア！', {
            fontSize: `${clearFontSize}px`,
            fill: Phaser.Display.Color.IntegerToColor(COLORS.warning).rgba,
            align: 'center',
            wordWrap: { width: width * 0.9 }
        }).setOrigin(0.5, 0.5);

        const messageFontSize = calculateResponsiveSize(this, 0.06);
        const randomMessage = Phaser.Utils.Array.GetRandom(this.messages);
        this.add.text(width / 2, height * 0.3, randomMessage, {
            fontSize: `${messageFontSize}px`,
            fill: '#000',
            align: 'center',
            wordWrap: { width: width * 0.9 }
        }).setOrigin(0.5, 0.5);

        this.createParticleEffect();

        // ボタン
        const buttonWidth = width * 0.4;
        const buttonHeight = height * 0.1;
        const buttonSpacing = width * 0.05;
        const buttonYPosition = height * 0.58;

        // 「もういちど」
        createCustomButton(
            this, 'もういちど',
            width / 2 - buttonWidth / 2 - buttonSpacing / 2,
            buttonYPosition,
            buttonWidth,
            buttonHeight,
            COLORS.info,
            COLORS.infoHover,
            () => {
                this.scene.start('CountdownScene', {
                    displayTime: this.displayTime,
                    level: this.level,
                    gridSize: this.gridSize,
                    gameMode: this.gameMode
                });
            }
        );
        // 「つぎのれべる」
        createCustomButton(
            this, 'つぎのれべる',
            width / 2 + buttonWidth / 2 + buttonSpacing / 2,
            buttonYPosition,
            buttonWidth,
            buttonHeight,
            COLORS.success,
            COLORS.successHover,
            () => {
                this.scene.start('CountdownScene', {
                    displayTime: this.displayTime,
                    level: this.level + 1,
                    gridSize: this.gridSize,
                    gameMode: this.gameMode
                });
            }
        );
    }
}

/* ========== シーン5: Retry =========== */
class RetryScene extends BaseScene {
    constructor() { super('RetryScene'); }
    preload() { super.preload(); }
    init(data) {
        super.init(data);
        this.grid = data.grid;
        this.wrongCells = data.wrongCells;
    }
    create() {
        this.createBackground();
        const { width, height } = this.scale;
        this.addCharacter(width * 0.15, height * 0.85, 0.54, 'だいじょうぶ！ もういちどやってみよう');
        const gameOverFontSize = calculateResponsiveSize(this, 0.08);
        this.add.text(width / 2, height * 0.18, 'ゲームオーバー', {
            fontSize: `${gameOverFontSize}px`,
            fill: '#FF0000',
            align: 'center',
            wordWrap: { width: width * 0.9 }
        }).setOrigin(0.5, 0.5);
        this.drawGrid();
        this.grid.forEach(cell => {
            if (this.gameMode === 'number' && cell.number !== null) {
                const numberFontSize = calculateResponsiveSize(this, 0.06);
                this.add.text(cell.x, cell.y, cell.number, {
                    fontSize: `${numberFontSize}px`,
                    fill: '#fff',
                    backgroundColor: Phaser.Display.Color.IntegerToColor(COLORS.danger).rgba,
                    padding: { x: 10, y: 10 },
                    borderRadius: 10,
                    align: 'center'
                }).setOrigin(0.5, 0.5).setVisible(true);
            } else if (this.gameMode === 'color' && cell.color !== null) {
                const colorBlock = this.add.rectangle(cell.x, cell.y, cell.width * 0.8, cell.height * 0.6, cell.color)
                    .setOrigin(0.5, 0.5)
                    .setAlpha(1);
            }
        });
        this.wrongCells.forEach(wrongCell => {
            const cell = this.grid.find(c => c.row === wrongCell.row && c.col === wrongCell.col);
            if (cell) {
                const xMarkFontSize = calculateResponsiveSize(this, 0.1);
                this.add.text(cell.x, cell.y, '×', {
                    fontSize: `${xMarkFontSize}px`,
                    fill: '#FF0000',
                    align: 'center'
                }).setOrigin(0.5, 0.5);
            }
        });
        // 「もういちど」
        createCustomButton(
            this, 'もういちど',
            width / 2,
            height * 0.65,
            width * 0.6,
            height * 0.12,
            COLORS.danger,
            COLORS.dangerHover,
            () => {
                this.scene.start('CountdownScene', {
                    displayTime: this.displayTime,
                    level: this.level,
                    gridSize: this.gridSize,
                    gameMode: this.gameMode
                });
            }
        );
        // 「さいしょから」
        createCustomButton(
            this, 'さいしょから',
            width / 2,
            height * 0.8,
            width * 0.6,
            height * 0.12,
            COLORS.info,
            COLORS.infoHover,
            () => {
                this.scene.start('SelectionScene');
            }
        );
    }
}

/* ========== Phaser設定 ========== */
const config = {
    type: Phaser.AUTO,
    parent: 'game-container',
    width: window.innerWidth,
    height: window.innerHeight,
    backgroundColor: '#f0f8ff',
    scene: [SelectionScene, CountdownScene, GameScene, ClearScene, RetryScene],
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: window.innerWidth,
        height: window.innerHeight
    },
    resolution: window.devicePixelRatio
};
const game = new Phaser.Game(config);
window.addEventListener('resize', () => {
    game.scale.resize(window.innerWidth, window.innerHeight);
});

/* ========== オンライン・オフライン状態表示 ========== */
window.addEventListener('load', () => {
    function updateOnlineStatus() {
        let statusDisplay = document.getElementById('status-display');
        if (!statusDisplay) {
            statusDisplay = document.createElement('div');
            statusDisplay.id = 'status-display';
            document.body.appendChild(statusDisplay);
        }
        if (navigator.onLine) {
            statusDisplay.textContent = 'オンライン';
            statusDisplay.style.backgroundColor = '#4CAF50';
            statusDisplay.style.color = 'white';
            setTimeout(() => {
                if (document.getElementById('status-display')) {
                    document.getElementById('status-display').remove();
                }
            }, 3000);
        } else {
            statusDisplay.textContent = 'オフラインモード';
            statusDisplay.style.backgroundColor = '#FF9800';
            statusDisplay.style.color = 'white';
        }
    }
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
    updateOnlineStatus();
});
</script>
</body>
</html>
